#!/usr/bin/env python3
"""
Smart Patch Processor v2.0 - Main Function Enhanced
Fonction main() compl√®te avec syst√®me d'aide int√©gr√©
"""

import sys
import argparse
from pathlib import Path
from unittest.mock import patch, mock_open
import traceback

# Imports du syst√®me de base

# Protection contre les erreurs d'import manquantes
def safe_import(module_name, fallback=None):
    try:
        return __import__(module_name)
    except ImportError:
        return fallback

# Protection contre les erreurs d'import manquantes
def safe_import(module_name, fallback=None):
    try:
        return __import__(module_name)
    except ImportError:
        return fallback
from cache_system import DummyCache
from streaming_system import CircularBuffer
from file_permissions import FilePermissions

# Imports locaux du Smart Patch Processor
from analyze_patch_step import AnalyzePatchStep
from apply_patch_step import ApplyPatchStep
from ast_analyzer import ASTAnalyzer
from cache_system import CacheManager
from colors import Colors
from correct_patch_step import CorrectPatchStep
from detect_target_step import DetectTargetStep
from git_integration import GitIntegration
from interactive_cli import InteractiveCLI
from line_number_corrector import LineNumberCorrector
from patch_analyzer import PatchAnalyzer
from patch_applicator import PatchApplicator
from patch_previewer import PatchPreviewer
from patch_processor_config import PatchProcessorConfig
from permission_manager import PermissionManager
from processing_coordinator import ProcessingCoordinator
from rollback_manager import RollbackManager
from smart_patch_processor import SmartPatchProcessor
from streaming_system import StreamingManager
from target_file_detector import TargetFileDetector
from wizard_mode import WizardMode

# Import du syst√®me d'aide am√©lior√©
try:
    from help_system import show_help, enhance_argument_parser, handle_help_command
    ENHANCED_HELP_AVAILABLE = True
except ImportError:
    ENHANCED_HELP_AVAILABLE = False
    print(f"{Colors.YELLOW}‚ö†Ô∏è Syst√®me d'aide avanc√© non disponible (help_system.py manquant){Colors.END}")

# Import du nouveau syst√®me guid√©
GUIDED_SYSTEM_AVAILABLE = True
print(f"{Colors.GREEN}üì¶ Syst√®me de patchage guid√© int√©gr√© charg√©{Colors.END}")


def create_argument_parser():
    """Cr√©e et configure l'argument parser avec toutes les options"""

    # Description compl√®te avec exemples
    description = """
Smart Patch Processor v2.0 - Traitement intelligent de patches avec mode guid√©

üéØ MODES PRINCIPAUX:
  --guided    Mode guid√© recommand√© (interface s√©curis√©e pas-√†-pas)
  --wizard    Assistant interactif pour d√©butants
  --interactive   Mode interactif avec confirmations

üí° EXEMPLES RAPIDES:
  %(prog)s --wizard                              # Premier usage recommand√©
  %(prog)s --guided patches/ output/             # Mode guid√© standard
  %(prog)s --guided --preview-only patches/ /tmp/ # Aper√ßu seulement
  %(prog)s fix.patch output/ --target file.py   # Patch explicite
"""

    epilog = """
üìö AIDE SP√âCIALIS√âE:
  --help-topic guided        Guide d√©taill√© du mode guid√©
  --help-topic wizard        Aide du mode assistant
  --help-topic examples      Exemples par situation
  --help-topic config        Configuration avanc√©e
  --help-topic troubleshooting   D√©pannage complet

üåü PREMI√àRE FOIS ? Lancez: %(prog)s --wizard

üìß Support: smart-patch-processor@example.com
üåê Documentation: https://smart-patch-processor.readthedocs.io/
"""

    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False  # On g√®re --help nous-m√™mes
    )

    # === ARGUMENTS PRINCIPAUX ===
    parser.add_argument('source', nargs='?',
                       help='Dossier de patches ou fichier patch unique')
    parser.add_argument('output', nargs='?',
                       help='Dossier de destination')

    # === MODE EXPLICITE ===
    explicit_group = parser.add_argument_group('üéØ Mode explicite')
    explicit_group.add_argument('-p', '--patch',
                               help='Fichier patch sp√©cifique')
    explicit_group.add_argument('-t', '--target',
                               help='Fichier cible sp√©cifique')
    explicit_group.add_argument('-o', '--output-dir',
                               help='Dossier de sortie')

    # === OPTIONS STANDARD ===
    standard_group = parser.add_argument_group('‚öôÔ∏è Options standard')
    standard_group.add_argument('-v', '--verbose', action='store_true',
                               help='Affichage d√©taill√©')
    standard_group.add_argument('-q', '--quiet', action='store_true',
                               help='Mode silencieux (erreurs uniquement)')
    standard_group.add_argument('-r', '--report', action='store_true',
                               help='G√©n√©rer un rapport d√©taill√©')
    standard_group.add_argument('--no-color', action='store_true',
                               help='D√©sactiver les couleurs')
    standard_group.add_argument('-c', '--config',
                               help='Fichier de configuration (JSON/YAML)')

    # === üéØ MODE GUID√â ===
    guided_group = parser.add_argument_group('üéØ Mode guid√© (recommand√©)')
    guided_group.add_argument('--guided', action='store_true',
                             help='üéØ Mode patchage guid√© interactif avec preview')
    guided_group.add_argument('--backup-dir',
                             help='üìÅ Dossier de backup personnalis√© (ex: ~/backups)')
    guided_group.add_argument('--modify-original', action='store_true',
                             help='‚úèÔ∏è Modifier directement les fichiers originaux')
    guided_group.add_argument('--preview-only', action='store_true',
                             help='üëÅÔ∏è Preview uniquement, sans application')
    guided_group.add_argument('--batch-mode', action='store_true',
                             help='üì¶ Mode lot sans interruption')

    # === üßô‚Äç‚ôÇÔ∏è MODES SP√âCIAUX ===
    special_group = parser.add_argument_group('üßô‚Äç‚ôÇÔ∏è Modes sp√©ciaux')
    special_group.add_argument('--wizard', action='store_true',
                              help='üßô‚Äç‚ôÇÔ∏è Mode assistant interactif pour d√©butants')
    special_group.add_argument('--interactive', action='store_true',
                              help='üí¨ Mode interactif avec confirmations')
    special_group.add_argument('--create-config', action='store_true',
                              help='‚öôÔ∏è Cr√©er une configuration personnalis√©e')
    special_group.add_argument('--test', action='store_true',
                              help='üß™ Ex√©cuter les tests unitaires')

    # === üîß OPTIONS AVANC√âES ===
    advanced_group = parser.add_argument_group('üîß Options avanc√©es')
    advanced_group.add_argument('--rollback', action='store_true',
                               help='üîÑ Activer le syst√®me de rollback')
    advanced_group.add_argument('--no-backup', action='store_true',
                               help='‚ö†Ô∏è D√©sactiver les sauvegardes automatiques')
    advanced_group.add_argument('--streaming', action='store_true',
                               help='üöÄ Forcer le mode streaming pour gros fichiers')
    advanced_group.add_argument('--ast-analysis', action='store_true',
                               help='üß† Activer l\'analyse syntaxique AST')
    advanced_group.add_argument('--git-integration', action='store_true',
                               help='üîó Activer l\'int√©gration Git')

    # === üìä SORTIE ET RAPPORTS ===
    output_group = parser.add_argument_group('üìä Sortie et rapports')
    output_group.add_argument('--output-format', choices=['json', 'yaml', 'html'],
                             default='json', help='Format du rapport de sortie')
    output_group.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
                             default='WARNING', help='Niveau de logging')
    output_group.add_argument('--log-file',
                             help='Fichier de log personnalis√©')

    # === ‚ùì AIDE ===
    help_group = parser.add_argument_group('‚ùì Aide et information')
    help_group.add_argument('-h', '--help', action='store_true',
                           help='Affiche cette aide d√©taill√©e')
    help_group.add_argument('--version', action='version',
                           version='Smart Patch Processor v2.0')

    # Int√©grer le syst√®me d'aide avanc√© si disponible - CORRECTION DU CONFLIT
    if ENHANCED_HELP_AVAILABLE:
        # SUPPRIMER LA LIGNE CONFLICTUELLE qui est d√©j√† d√©finie dans enhance_argument_parser
        # help_group.add_argument('--help-topic', ...)  # <- Cette ligne causait le conflit
        parser = enhance_argument_parser(parser)

    return parser


def validate_arguments(args):
    """Valide et normalise les arguments"""
    errors = []
    warnings = []

    # === VALIDATION DES MODES ===

    # Compter les modes actifs
    active_modes = sum([
        bool(args.wizard),
        bool(args.guided),
        bool(args.create_config),
        bool(args.test)
    ])

    if active_modes > 1:
        errors.append("Un seul mode peut √™tre actif √† la fois (--wizard, --guided, --create-config, --test)")

    # === VALIDATION DES FICHIERS ===

    # Mode wizard, create-config et test n'ont pas besoin de fichiers
    if not any([args.wizard, args.create_config, args.test]):

        # D√©terminer les chemins source/output
        source_path = args.patch or args.source
        output_path = args.output_dir or args.output

        if not source_path:
            errors.append("Source requise (fichier patch ou dossier)")

        if not output_path and not args.preview_only:
            errors.append("Destination requise (sauf pour --preview-only)")

        # V√©rifier l'existence des fichiers
        if source_path and not Path(source_path).exists():
            errors.append(f"Fichier/dossier source introuvable: {source_path}")

        if args.target and not Path(args.target).exists():
            errors.append(f"Fichier cible introuvable: {args.target}")

        if args.config and not Path(args.config).exists():
            errors.append(f"Fichier de configuration introuvable: {args.config}")

    # === VALIDATION DES OPTIONS ===

    # Conflits d'options
    if args.modify_original and args.preview_only:
        errors.append("--modify-original et --preview-only sont incompatibles")

    if args.no_backup and args.backup_dir:
        warnings.append("--no-backup ignore --backup-dir")

    if args.quiet and args.verbose:
        warnings.append("--quiet et --verbose sont contradictoires, --verbose prioritaire")

    # === NORMALISATION ===

    # Priorit√© verbose > quiet
    if args.verbose:
        args.quiet = False

    # Mode guid√© automatique pour d√©butants si d√©tect√©
    if not any([args.wizard, args.guided, args.interactive]) and len(sys.argv) <= 3:
        warnings.append("Mode guid√© recommand√© pour la premi√®re utilisation (ajoutez --guided)")

    return errors, warnings


def handle_special_modes(args):
    """G√®re les modes sp√©ciaux qui ne font pas de traitement de patches"""

    # === MODE AIDE ===
    if args.help:
        if ENHANCED_HELP_AVAILABLE:
            show_help('main')
        else:
            # Fallback vers aide standard
            create_argument_parser().print_help()
        return True

    if ENHANCED_HELP_AVAILABLE and handle_help_command(args):
        return True

    # === MODE CR√âATION DE CONFIGURATION ===
    if args.create_config:
        success = run_config_generator()
        sys.exit(0 if success else 1)

    # === MODE TESTS ===
    if args.test:
        success = run_tests()
        sys.exit(0 if success else 1)

    # === MODE WIZARD ===
    if args.wizard:
        try:
            # Cr√©er un processeur temporaire pour le wizard
            processor = SmartPatchProcessor('.', '.', args.verbose, args.config)
            processor.print_banner()

            wizard = processor.wizard_mode
            if wizard and (wizard.is_enabled() or True):  # Force enable pour --wizard
                result = wizard.run_wizard()

                # üî• CORRECTION: V√©rifier si le traitement a √©t√© effectu√©
                if result.get('completed'):
                    if result.get('processing_completed'):
                        print("üí° Exemples d'usage pour la prochaine fois:")
                        print("   smart-patch --guided patches/ output/")
                        print("   smart-patch single.patch output/ --target myfile.py")
                        return True  # Indiquer que tout est termin√©
                    else:
                        print("‚ú® Configuration termin√©e !")
                        print("üí° Les patches n'ont pas √©t√© appliqu√©s automatiquement.")
                        print("üí° Relancez avec les param√®tres configur√©s :")
                        print("   smart-patch --guided patches/ output/")
                        return True
                else:
                    print("üëã √Ä bient√¥t ! Lancez √† nouveau avec --wizard quand vous voulez.")
                    return True
            return True
        except Exception as e:
            print(f"‚ùå Erreur wizard: {e}")
            if args.verbose:
                traceback.print_exc()
            return True  # Toujours terminer m√™me en cas d'erreur

    return False


def determine_processing_mode(args):
    """D√©termine le mode de traitement et les param√®tres"""

    # D√©terminer les chemins
    if args.patch and args.target and args.output_dir:
        # Mode explicite avec flags
        source_path = args.patch
        target_path = args.target
        output_path = args.output_dir
        mode = "explicit_flags"
    elif args.source and args.output and args.target:
        # Mode explicite avec arguments positionnels + --target
        source_path = args.source
        target_path = args.target
        output_path = args.output
        mode = "explicit_mixed"
    elif args.source and (args.output or args.preview_only):
        # Mode standard
        source_path = args.source
        output_path = args.output or '/tmp'  # Fallback pour preview-only
        target_path = None
        mode = "standard"
    else:
        return None, None, None, None

    # D√©terminer le sous-mode
    if args.guided:
        if args.preview_only:
            submode = "guided_preview"
        elif args.batch_mode:
            submode = "guided_batch"
        elif args.interactive:
            submode = "guided_interactive"
        else:
            submode = "guided_standard"
    elif args.interactive:
        submode = "interactive"
    else:
        submode = "standard"

    return mode, submode, source_path, output_path, target_path


def setup_logging(args):
    """Configure le syst√®me de logging"""
    import logging

    # Niveau bas√© sur les arguments
    if args.verbose:
        level = logging.DEBUG
        console_level = logging.INFO
    elif args.quiet:
        level = logging.ERROR
        console_level = logging.ERROR
    else:
        level = getattr(logging, args.log_level, logging.WARNING)
        console_level = logging.WARNING

    # Configuration du logger principal
    logger = logging.getLogger('smart_patch_processor')
    logger.setLevel(level)

    # Supprimer les handlers existants
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Handler console
    console_handler = logging.StreamHandler()
    console_handler.setLevel(console_level)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Handler fichier si sp√©cifi√©
    if args.log_file:
        file_handler = logging.FileHandler(args.log_file)
        file_handler.setLevel(level)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        logger.info(f"Logging vers fichier: {args.log_file}")


def run_tests():
    """Ex√©cute les tests unitaires du Smart Patch Processor"""
    try:
        import unittest

        print(f"{Colors.BLUE}üß™ Ex√©cution des tests unitaires...{Colors.END}")

        # D√©couvrir et ex√©cuter les tests
        loader = unittest.TestLoader()
        start_dir = Path(__file__).parent
        suite = loader.discover(start_dir, pattern='test_*.py')

        runner = unittest.TextTestRunner(verbosity=2)
        result = runner.run(suite)

        # Afficher le r√©sum√©
        if result.wasSuccessful():
            print(f"{Colors.GREEN}‚úÖ Tous les tests sont pass√©s ({result.testsRun} tests){Colors.END}")
            return True
        else:
            failures = len(result.failures)
            errors = len(result.errors)
            print(f"{Colors.RED}‚ùå {failures} √©chec(s), {errors} erreur(s) sur {result.testsRun} tests{Colors.END}")
            return False

    except ImportError as e:
        print(f"{Colors.YELLOW}‚ö†Ô∏è Impossible de charger les tests: {e}{Colors.END}")
        return False
    except Exception as e:
        print(f"{Colors.RED}‚ùå Erreur lors des tests: {e}{Colors.END}")
        return False


def run_guided_patching(args, source_path, output_path, target_path):
    """Lance le mode patchage guid√©"""

    print(f"{Colors.CYAN}üéØ Lancement du patchage guid√©{Colors.END}")

    if args.preview_only:
        print(f"{Colors.BLUE}üëÅÔ∏è Mode preview uniquement activ√©{Colors.END}")

    if args.batch_mode:
        print(f"{Colors.PURPLE}üì¶ Mode batch activ√© - traitement sans interruption{Colors.END}")

    # Cr√©er le processeur principal
    processor = SmartPatchProcessor(
        source_path,
        output_path,
        args.verbose,
        args.config,
        target_path
    )

    # Configuration sp√©cifique au mode guid√©
    if args.backup_dir:
        # TODO: Configurer le r√©pertoire de backup personnalis√©
        print(f"{Colors.CYAN}üíæ Backup personnalis√©: {args.backup_dir}{Colors.END}")

    if args.modify_original:
        print(f"{Colors.YELLOW}‚ö†Ô∏è Modification directe des originaux activ√©e{Colors.END}")

    # Trouver les patches
    if Path(source_path).is_file():
        patches = [Path(source_path)]
        print(f"{Colors.BLUE}üìÑ Mode fichier unique: {Path(source_path).name}{Colors.END}")
    else:
        patches = processor.find_patches()
        print(f"{Colors.BLUE}üìÅ Mode dossier: {len(patches)} patch(es) trouv√©(s){Colors.END}")

    if not patches:
        print(f"{Colors.RED}‚ùå Aucun patch trouv√©{Colors.END}")
        return False

    # Affichage des patches trouv√©s
    for i, patch in enumerate(patches, 1):
        size_kb = patch.stat().st_size // 1024
        print(f"   {i:2d}. {patch.name} ({size_kb}KB)")

    # Confirmation si mode interactif
    if args.interactive and not args.batch_mode:
        response = input(f"\n{Colors.CYAN}Continuer avec le traitement ? (y/N): {Colors.END}").strip().lower()
        if response != 'y':
            print(f"{Colors.YELLOW}Traitement annul√© par l'utilisateur{Colors.END}")
            return False

    # Traitement des patches
    if args.preview_only:
        # Mode preview uniquement
        print(f"\n{Colors.CYAN}üëÅÔ∏è APER√áU DES MODIFICATIONS{Colors.END}")
        success_count = 0

        for i, patch_path in enumerate(patches, 1):
            print(f"\n[{i}/{len(patches)}] üìÑ {patch_path.name}")

            try:
                with open(patch_path, 'r') as f:
                    content = f.read()
                    lines = len(content.split('\n'))
                    print(f"  üìä {lines} lignes, ~{content.count('@@')} section(s)")

                    # Analyser les modifications
                    additions = content.count('\n+')
                    deletions = content.count('\n-')
                    print(f"  üìà ~{additions} addition(s), {deletions} suppression(s)")

                success_count += 1
                print(f"  ‚úÖ Preview g√©n√©r√©")

            except Exception as e:
                print(f"  ‚ùå Erreur: {e}")

        print(f"\nüìä R√©sum√© preview: {success_count}/{len(patches)} patch(es) analys√©(s)")
        return success_count > 0

    else:
        # Mode traitement normal
        print(f"\n{Colors.GREEN}‚ö° TRAITEMENT DES PATCHES{Colors.END}")
        summary = processor.process_all_patches()

        # G√©n√©rer un rapport si demand√©
        if args.report:
            report_file = processor.generate_report(summary)
            print(f"\n{Colors.CYAN}üìÑ Rapport g√©n√©r√©: {report_file}{Colors.END}")

        return summary['success'] > 0


def run_config_generator():
    """Lance le g√©n√©rateur de configuration"""
    try:
        from advanced_config_generator import run_config_generator_advanced
        return run_config_generator_advanced()
    except ImportError:
        # Fallback vers version simple
        print("üîß G√©n√©rateur de Configuration Smart Patch Processor (version simple)")

        config = {
            "detection": {"file_extensions": [".py", ".js", ".ts", ".php", ".java"]},
            "security": {"scan_dangerous_patterns": True, "allow_system_calls": False},
            "guided_patching": {"enabled": True, "preview_enabled": True, "auto_backup": True},
            "logging": {"level": "WARNING", "console_level": "ERROR"}
        }

        import json
        output_file = Path("smart_patch_config.json")
        with open(output_file, 'w') as f:
            json.dump(config, f, indent=2)

        print(f"‚úÖ Configuration cr√©√©e: {output_file}")
        return True
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False


def main():
    """Fonction principale am√©lior√©e avec gestion compl√®te des arguments"""

    # === PHASE 1: PARSING ET VALIDATION ===
    parser = create_argument_parser()
    args = parser.parse_args()

    # D√©sactiver les couleurs si demand√©
    if args.no_color:
        Colors.disable_colors()

    # Valider les arguments
    errors, warnings = validate_arguments(args)

    # Afficher les avertissements
    for warning in warnings:
        print(f"{Colors.YELLOW}‚ö†Ô∏è {warning}{Colors.END}")

    # Arr√™ter si erreurs
    if errors:
        print(f"{Colors.RED}‚ùå Erreurs de validation:{Colors.END}")
        for error in errors:
            print(f"   ‚Ä¢ {error}")
        parser.print_usage()
        sys.exit(1)

    # === PHASE 2: CONFIGURATION ===
    setup_logging(args)

    # === PHASE 3: MODES SP√âCIAUX ===
    if handle_special_modes(args):
        return

    # === PHASE 4: D√âTERMINATION DU MODE DE TRAITEMENT ===
    mode, submode, source_path, output_path, target_path = determine_processing_mode(args)

    if mode is None:
        print(f"{Colors.RED}‚ùå Arguments insuffisants{Colors.END}")
        print(f"\n{Colors.CYAN}Utilisations possibles:{Colors.END}")
        print(f"  {Colors.GREEN}Mode d√©butant:{Colors.END}        smart-patch --wizard")
        print(f"  {Colors.GREEN}Mode guid√©:{Colors.END}           smart-patch --guided patches/ output/")
        print(f"  {Colors.YELLOW}Mode explicite:{Colors.END}       smart-patch patch.diff output/ --target file.py")
        print(f"  {Colors.PURPLE}Cr√©er config:{Colors.END}         smart-patch --create-config")
        print(f"  {Colors.BLUE}Aide compl√®te:{Colors.END}        smart-patch --help")
        if ENHANCED_HELP_AVAILABLE:
            print(f"  {Colors.BLUE}Aide sp√©cialis√©e:{Colors.END}     smart-patch --help-topic examples")
        sys.exit(1)

    # === PHASE 5: TRAITEMENT PRINCIPAL ===
    try:
        # Affichage du mode et banni√®re
        if not args.quiet:
            # Banni√®re
            print(f"{Colors.CYAN}{Colors.BOLD}")
            print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print("‚ïë          üöÄ SMART PATCH PROCESSOR v2.0                         ‚ïë")
            print("‚ïë      Traitement Intelligent de Patches avec Mode Guid√©         ‚ïë")
            print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
            print(f"{Colors.END}")

            # Affichage du mode
            mode_descriptions = {
                "explicit_flags": f"{Colors.PURPLE}üéØ Mode explicite avec flags{Colors.END}",
                "explicit_mixed": f"{Colors.PURPLE}üéØ Mode explicite mixte{Colors.END}",
                "standard": f"{Colors.BLUE}üìÅ Mode standard{Colors.END}"
            }

            submode_descriptions = {
                "guided_standard": f"{Colors.GREEN}üéØ Mode guid√© standard{Colors.END}",
                "guided_preview": f"{Colors.CYAN}üëÅÔ∏è Mode guid√© preview{Colors.END}",
                "guided_batch": f"{Colors.PURPLE}üì¶ Mode guid√© batch{Colors.END}",
                "guided_interactive": f"{Colors.YELLOW}üí¨ Mode guid√© interactif{Colors.END}",
                "interactive": f"{Colors.YELLOW}üí¨ Mode interactif{Colors.END}",
                "standard": f"{Colors.BLUE}‚ö° Mode standard{Colors.END}"
            }

            print(f"{mode_descriptions.get(mode, mode)} ‚Ä¢ {submode_descriptions.get(submode, submode)}")

            if Path(source_path).is_file():
                print(f"üìÑ Fichier: {Path(source_path).name}")
            else:
                print(f"üìÅ Dossier: {Path(source_path).name}")

            if target_path:
                print(f"üéØ Cible: {Path(target_path).name}")

            print()

        # === TRAITEMENT SELON LE MODE ===
        success = False

        if submode.startswith('guided'):
            # Mode guid√©
            success = run_guided_patching(args, source_path, output_path, target_path)

        else:
            # Mode standard ou interactif
            processor = SmartPatchProcessor(
                source_path,
                output_path,
                args.verbose,
                args.config,
                target_path
            )

            if args.interactive:
                print(f"{Colors.CYAN}üîÑ Mode interactif activ√©{Colors.END}")

            # Traitement
            summary = processor.process_all_patches()

            # G√©n√©rer un rapport si demand√©
            if args.report:
                report_file = processor.generate_report(summary)
                print(f"\n{Colors.CYAN}üìÑ Rapport g√©n√©r√©: {report_file}{Colors.END}")

            success = summary['success'] > 0

        # === CODES DE SORTIE ===
        if success:
            if not args.quiet:
                print(f"\n{Colors.GREEN}üéâ Traitement termin√© avec succ√®s !{Colors.END}")
            sys.exit(0)
        else:
            if not args.quiet:
                print(f"\n{Colors.RED}‚ùå Traitement √©chou√©{Colors.END}")
            sys.exit(1)

    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}‚ö†Ô∏è Traitement interrompu par l'utilisateur{Colors.END}")
        sys.exit(130)
    except Exception as e:
        print(f"{Colors.RED}‚ùå Erreur fatale: {e}{Colors.END}")
        if args.verbose:
            traceback.print_exc()
        sys.exit(1)


def print_guided_examples():
    """Affiche des exemples d'utilisation du mode guid√©"""

    print(f"{Colors.CYAN}{Colors.BOLD}")
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë                   üéØ EXEMPLES MODE GUID√â                         ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print(f"{Colors.END}")

    examples = [
        {
            'title': 'üî∞ D√©butant - Mode guid√© de base',
            'command': 'smart-patch --guided patches/ output/',
            'description': 'Mode guid√© avec toutes les s√©curit√©s et confirmations'
        },
        {
            'title': 'üíæ Backup personnalis√©',
            'command': 'smart-patch --guided --backup-dir ~/mes_backups patches/ output/',
            'description': 'Sauvegardes dans un dossier sp√©cifique'
        },
        {
            'title': '‚úèÔ∏è Modification directe des originaux',
            'command': 'smart-patch --guided --modify-original patches/ output/',
            'description': 'Modifie directement les fichiers sans cr√©er de copies'
        },
        {
            'title': 'üëÅÔ∏è Preview uniquement',
            'command': 'smart-patch --guided --preview-only patches/ /tmp/',
            'description': 'Voir les changements sans les appliquer'
        },
        {
            'title': '‚öôÔ∏è Avec configuration personnalis√©e',
            'command': 'smart-patch --guided --config ma_config.json patches/ output/',
            'description': 'Utilise une configuration cr√©√©e avec --create-config'
        },
        {
            'title': 'üéØ Patch unique avec cible explicite',
            'command': 'smart-patch --guided fix.patch output/ --target myfile.py',
            'description': 'Mode guid√© pour un patch sp√©cifique'
        },
        {
            'title': 'üì¶ Mode batch pour lots de patches',
            'command': 'smart-patch --guided --batch-mode patches/ output/',
            'description': 'Traitement automatique sans interruption'
        },
        {
            'title': 'üí¨ Mode interactif avec confirmations',
            'command': 'smart-patch --guided --interactive patches/ output/',
            'description': 'Confirmation manuelle pour chaque patch'
        }
    ]

    for example in examples:
        print(f"\n{Colors.BOLD}{example['title']}{Colors.END}")
        print(f"   {Colors.GREEN}{example['command']}{Colors.END}")
        print(f"   üí° {example['description']}")

    print(f"\n{Colors.BLUE}üí° Conseils:{Colors.END}")
    print("   ‚Ä¢ Utilisez --create-config pour cr√©er une configuration personnalis√©e")
    print("   ‚Ä¢ Le mode guid√© vous permet de valider chaque patch avant application")
    print("   ‚Ä¢ Les backups sont automatiques et personnalisables")
    print("   ‚Ä¢ Utilisez --verbose pour plus de d√©tails")
    print("   ‚Ä¢ Commencez par --wizard si c'est votre premi√®re fois")


def show_welcome_message():
    """Affiche le message d'accueil pour nouveaux utilisateurs"""

    print(f"{Colors.CYAN}{Colors.BOLD}")
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë               üëã BIENVENUE DANS SMART PATCH PROCESSOR            ‚ïë")
    print("‚ïë                           v2.0                                   ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print(f"{Colors.END}")

    print(f"{Colors.BLUE}üéØ Smart Patch Processor applique intelligemment vos patches{Colors.END}")
    print("avec d√©tection automatique, correction des erreurs et s√©curit√© avanc√©e.")
    print()

    print(f"{Colors.GREEN}üåü PREMI√àRE FOIS ? Trois options simples:{Colors.END}")
    print(f"   1. {Colors.CYAN}smart-patch --wizard{Colors.END}                    üßô‚Äç‚ôÇÔ∏è Assistant pas-√†-pas")
    print(f"   2. {Colors.CYAN}smart-patch --guided patches/ output/{Colors.END}   üéØ Mode guid√© s√©curis√©")
    print(f"   3. {Colors.CYAN}smart-patch --help{Colors.END}                      üìö Aide compl√®te")
    print()

    print(f"{Colors.YELLOW}üí° Le mode guid√© est recommand√© pour tous les utilisateurs !{Colors.END}")


def detect_user_context():
    """D√©tecte le contexte utilisateur pour sugg√©rer le meilleur mode"""
    context = {
        'is_beginner': True,
        'has_patches': False,
        'in_git_repo': False,
        'suggested_mode': 'wizard'
    }

    # D√©tecter la pr√©sence de patches
    current_dir = Path.cwd()
    patch_files = list(current_dir.glob('*.patch')) + list(current_dir.glob('*.diff'))
    if patch_files:
        context['has_patches'] = True
        context['patch_count'] = len(patch_files)

    # D√©tecter si on est dans un repo Git
    git_dir = current_dir / '.git'
    if git_dir.exists():
        context['in_git_repo'] = True

    # D√©tecter l'exp√©rience (bas√© sur l'historique des commandes)
    try:
        home = Path.home()
        bash_history = home / '.bash_history'
        zsh_history = home / '.zsh_history'

        patch_commands = ['patch', 'git apply', 'smart-patch']
        experience_score = 0

        for history_file in [bash_history, zsh_history]:
            if history_file.exists():
                try:
                    with open(history_file, 'r', errors='ignore') as f:
                        history = f.read()
                        for cmd in patch_commands:
                            experience_score += history.count(cmd)
                except:
                    pass

        if experience_score > 5:
            context['is_beginner'] = False
            context['suggested_mode'] = 'guided'
    except:
        pass

    # Suggestions bas√©es sur le contexte
    if context['has_patches'] and not context['is_beginner']:
        context['suggested_mode'] = 'guided'
    elif context['has_patches']:
        context['suggested_mode'] = 'wizard'

    return context


def show_context_suggestions():
    """Affiche des suggestions bas√©es sur le contexte d√©tect√©"""
    context = detect_user_context()

    print(f"{Colors.PURPLE}üéØ SUGGESTIONS PERSONNALIS√âES:{Colors.END}")

    if context['has_patches']:
        print(f"   ‚úÖ {context['patch_count']} patch(es) d√©tect√©(s) dans le r√©pertoire actuel")
        if context['is_beginner']:
            print(f"   üí° Recommandation: {Colors.CYAN}smart-patch --wizard{Colors.END}")
            print("      L'assistant vous guidera pas-√†-pas pour traiter vos patches")
        else:
            print(f"   üí° Recommandation: {Colors.GREEN}smart-patch --guided *.patch output/{Colors.END}")
            print("      Mode guid√© direct pour traiter tous vos patches")
    else:
        print("   üìÅ Aucun patch d√©tect√© dans le r√©pertoire actuel")
        print(f"   üí° Recommandation: {Colors.CYAN}smart-patch --wizard{Colors.END}")
        print("      L'assistant vous aidera √† localiser et traiter vos patches")

    if context['in_git_repo']:
        print("   üîó D√©p√¥t Git d√©tect√© - int√©gration Git disponible")
        print("      Ajoutez --git-integration pour cr√©er des branches automatiquement")

    print()


# Point d'entr√©e principal
if __name__ == "__main__":
    # Si appel√© sans arguments, afficher l'accueil et suggestions
    if len(sys.argv) == 1:
        show_welcome_message()
        show_context_suggestions()
        print_guided_examples()
        print(f"\n{Colors.YELLOW}Utilisez --help pour l'aide compl√®te{Colors.END}")
        sys.exit(0)

    # Sinon, lancer le traitement normal
    main()
